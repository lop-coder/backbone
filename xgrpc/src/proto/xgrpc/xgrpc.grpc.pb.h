// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: xgrpc.proto
#ifndef GRPC_xgrpc_2eproto__INCLUDED
#define GRPC_xgrpc_2eproto__INCLUDED

#include "xgrpc.pb.h"

#include <grpcpp/client_context.h>
#include <grpcpp/completion_queue.h>
#include <grpcpp/generic/async_generic_service.h>
#include <grpcpp/impl/proto_utils.h>
#include <grpcpp/impl/rpc_method.h>
#include <grpcpp/impl/server_callback_handlers.h>
#include <grpcpp/impl/service_type.h>
#include <grpcpp/server_context.h>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/support/client_callback.h>
#include <grpcpp/support/message_allocator.h>
#include <grpcpp/support/method_handler.h>
#include <grpcpp/support/server_callback.h>
#include <grpcpp/support/status.h>
#include <grpcpp/support/stub_options.h>
#include <grpcpp/support/sync_stream.h>
#include <functional>

namespace backbonerpc {

class XgRPC final {
 public:
  static constexpr char const* service_full_name() {
    return "backbonerpc.XgRPC";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status Call(::grpc::ClientContext* context,
                                const ::backbonerpc::Request& request,
                                ::backbonerpc::Response* response) = 0;
    std::unique_ptr<
        ::grpc::ClientAsyncResponseReaderInterface<::backbonerpc::Response>>
    AsyncCall(::grpc::ClientContext* context,
              const ::backbonerpc::Request& request,
              ::grpc::CompletionQueue* cq) {
      return std::unique_ptr<
          ::grpc::ClientAsyncResponseReaderInterface<::backbonerpc::Response>>(
          AsyncCallRaw(context, request, cq));
    }
    std::unique_ptr<
        ::grpc::ClientAsyncResponseReaderInterface<::backbonerpc::Response>>
    PrepareAsyncCall(::grpc::ClientContext* context,
                     const ::backbonerpc::Request& request,
                     ::grpc::CompletionQueue* cq) {
      return std::unique_ptr<
          ::grpc::ClientAsyncResponseReaderInterface<::backbonerpc::Response>>(
          PrepareAsyncCallRaw(context, request, cq));
    }
    std::unique_ptr<::grpc::ClientReaderInterface<::backbonerpc::Response>>
    Pull(::grpc::ClientContext* context,
         const ::backbonerpc::Request& request) {
      return std::unique_ptr<
          ::grpc::ClientReaderInterface<::backbonerpc::Response>>(
          PullRaw(context, request));
    }
    std::unique_ptr<::grpc::ClientAsyncReaderInterface<::backbonerpc::Response>>
    AsyncPull(::grpc::ClientContext* context,
              const ::backbonerpc::Request& request,
              ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr<
          ::grpc::ClientAsyncReaderInterface<::backbonerpc::Response>>(
          AsyncPullRaw(context, request, cq, tag));
    }
    std::unique_ptr<::grpc::ClientAsyncReaderInterface<::backbonerpc::Response>>
    PrepareAsyncPull(::grpc::ClientContext* context,
                     const ::backbonerpc::Request& request,
                     ::grpc::CompletionQueue* cq) {
      return std::unique_ptr<
          ::grpc::ClientAsyncReaderInterface<::backbonerpc::Response>>(
          PrepareAsyncPullRaw(context, request, cq));
    }
    std::unique_ptr<::grpc::ClientWriterInterface<::backbonerpc::Request>> Push(
        ::grpc::ClientContext* context, ::backbonerpc::Response* response) {
      return std::unique_ptr<
          ::grpc::ClientWriterInterface<::backbonerpc::Request>>(
          PushRaw(context, response));
    }
    std::unique_ptr<::grpc::ClientAsyncWriterInterface<::backbonerpc::Request>>
    AsyncPush(::grpc::ClientContext* context, ::backbonerpc::Response* response,
              ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr<
          ::grpc::ClientAsyncWriterInterface<::backbonerpc::Request>>(
          AsyncPushRaw(context, response, cq, tag));
    }
    std::unique_ptr<::grpc::ClientAsyncWriterInterface<::backbonerpc::Request>>
    PrepareAsyncPush(::grpc::ClientContext* context,
                     ::backbonerpc::Response* response,
                     ::grpc::CompletionQueue* cq) {
      return std::unique_ptr<
          ::grpc::ClientAsyncWriterInterface<::backbonerpc::Request>>(
          PrepareAsyncPushRaw(context, response, cq));
    }
    std::unique_ptr<::grpc::ClientReaderWriterInterface<
        ::backbonerpc::Request, ::backbonerpc::Response>>
    Bidi(::grpc::ClientContext* context) {
      return std::unique_ptr<::grpc::ClientReaderWriterInterface<
          ::backbonerpc::Request, ::backbonerpc::Response>>(BidiRaw(context));
    }
    std::unique_ptr<::grpc::ClientAsyncReaderWriterInterface<
        ::backbonerpc::Request, ::backbonerpc::Response>>
    AsyncBidi(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq,
              void* tag) {
      return std::unique_ptr<::grpc::ClientAsyncReaderWriterInterface<
          ::backbonerpc::Request, ::backbonerpc::Response>>(
          AsyncBidiRaw(context, cq, tag));
    }
    std::unique_ptr<::grpc::ClientAsyncReaderWriterInterface<
        ::backbonerpc::Request, ::backbonerpc::Response>>
    PrepareAsyncBidi(::grpc::ClientContext* context,
                     ::grpc::CompletionQueue* cq) {
      return std::unique_ptr<::grpc::ClientAsyncReaderWriterInterface<
          ::backbonerpc::Request, ::backbonerpc::Response>>(
          PrepareAsyncBidiRaw(context, cq));
    }
    std::unique_ptr<::grpc::ClientReaderInterface<::backbonerpc::Response>>
    Subscribe(::grpc::ClientContext* context,
              const ::backbonerpc::Request& request) {
      return std::unique_ptr<
          ::grpc::ClientReaderInterface<::backbonerpc::Response>>(
          SubscribeRaw(context, request));
    }
    std::unique_ptr<::grpc::ClientAsyncReaderInterface<::backbonerpc::Response>>
    AsyncSubscribe(::grpc::ClientContext* context,
                   const ::backbonerpc::Request& request,
                   ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr<
          ::grpc::ClientAsyncReaderInterface<::backbonerpc::Response>>(
          AsyncSubscribeRaw(context, request, cq, tag));
    }
    std::unique_ptr<::grpc::ClientAsyncReaderInterface<::backbonerpc::Response>>
    PrepareAsyncSubscribe(::grpc::ClientContext* context,
                          const ::backbonerpc::Request& request,
                          ::grpc::CompletionQueue* cq) {
      return std::unique_ptr<
          ::grpc::ClientAsyncReaderInterface<::backbonerpc::Response>>(
          PrepareAsyncSubscribeRaw(context, request, cq));
    }
    std::unique_ptr<::grpc::ClientWriterInterface<::backbonerpc::Request>>
    Publish(::grpc::ClientContext* context, ::backbonerpc::Response* response) {
      return std::unique_ptr<
          ::grpc::ClientWriterInterface<::backbonerpc::Request>>(
          PublishRaw(context, response));
    }
    std::unique_ptr<::grpc::ClientAsyncWriterInterface<::backbonerpc::Request>>
    AsyncPublish(::grpc::ClientContext* context,
                 ::backbonerpc::Response* response, ::grpc::CompletionQueue* cq,
                 void* tag) {
      return std::unique_ptr<
          ::grpc::ClientAsyncWriterInterface<::backbonerpc::Request>>(
          AsyncPublishRaw(context, response, cq, tag));
    }
    std::unique_ptr<::grpc::ClientAsyncWriterInterface<::backbonerpc::Request>>
    PrepareAsyncPublish(::grpc::ClientContext* context,
                        ::backbonerpc::Response* response,
                        ::grpc::CompletionQueue* cq) {
      return std::unique_ptr<
          ::grpc::ClientAsyncWriterInterface<::backbonerpc::Request>>(
          PrepareAsyncPublishRaw(context, response, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      virtual void Call(::grpc::ClientContext* context,
                        const ::backbonerpc::Request* request,
                        ::backbonerpc::Response* response,
                        std::function<void(::grpc::Status)>) = 0;
      virtual void Call(::grpc::ClientContext* context,
                        const ::backbonerpc::Request* request,
                        ::backbonerpc::Response* response,
                        ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void Pull(
          ::grpc::ClientContext* context, const ::backbonerpc::Request* request,
          ::grpc::ClientReadReactor<::backbonerpc::Response>* reactor) = 0;
      virtual void Push(
          ::grpc::ClientContext* context, ::backbonerpc::Response* response,
          ::grpc::ClientWriteReactor<::backbonerpc::Request>* reactor) = 0;
      virtual void Bidi(
          ::grpc::ClientContext* context,
          ::grpc::ClientBidiReactor<::backbonerpc::Request,
                                    ::backbonerpc::Response>* reactor) = 0;
      virtual void Subscribe(
          ::grpc::ClientContext* context, const ::backbonerpc::Request* request,
          ::grpc::ClientReadReactor<::backbonerpc::Response>* reactor) = 0;
      virtual void Publish(
          ::grpc::ClientContext* context, ::backbonerpc::Response* response,
          ::grpc::ClientWriteReactor<::backbonerpc::Request>* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }

   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface<::backbonerpc::Response>*
    AsyncCallRaw(::grpc::ClientContext* context,
                 const ::backbonerpc::Request& request,
                 ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface<::backbonerpc::Response>*
    PrepareAsyncCallRaw(::grpc::ClientContext* context,
                        const ::backbonerpc::Request& request,
                        ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface<::backbonerpc::Response>* PullRaw(
        ::grpc::ClientContext* context,
        const ::backbonerpc::Request& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface<::backbonerpc::Response>*
    AsyncPullRaw(::grpc::ClientContext* context,
                 const ::backbonerpc::Request& request,
                 ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface<::backbonerpc::Response>*
    PrepareAsyncPullRaw(::grpc::ClientContext* context,
                        const ::backbonerpc::Request& request,
                        ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientWriterInterface<::backbonerpc::Request>* PushRaw(
        ::grpc::ClientContext* context, ::backbonerpc::Response* response) = 0;
    virtual ::grpc::ClientAsyncWriterInterface<::backbonerpc::Request>*
    AsyncPushRaw(::grpc::ClientContext* context,
                 ::backbonerpc::Response* response, ::grpc::CompletionQueue* cq,
                 void* tag) = 0;
    virtual ::grpc::ClientAsyncWriterInterface<::backbonerpc::Request>*
    PrepareAsyncPushRaw(::grpc::ClientContext* context,
                        ::backbonerpc::Response* response,
                        ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderWriterInterface<::backbonerpc::Request,
                                                ::backbonerpc::Response>*
    BidiRaw(::grpc::ClientContext* context) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface<::backbonerpc::Request,
                                                     ::backbonerpc::Response>*
    AsyncBidiRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq,
                 void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface<::backbonerpc::Request,
                                                     ::backbonerpc::Response>*
    PrepareAsyncBidiRaw(::grpc::ClientContext* context,
                        ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface<::backbonerpc::Response>*
    SubscribeRaw(::grpc::ClientContext* context,
                 const ::backbonerpc::Request& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface<::backbonerpc::Response>*
    AsyncSubscribeRaw(::grpc::ClientContext* context,
                      const ::backbonerpc::Request& request,
                      ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface<::backbonerpc::Response>*
    PrepareAsyncSubscribeRaw(::grpc::ClientContext* context,
                             const ::backbonerpc::Request& request,
                             ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientWriterInterface<::backbonerpc::Request>* PublishRaw(
        ::grpc::ClientContext* context, ::backbonerpc::Response* response) = 0;
    virtual ::grpc::ClientAsyncWriterInterface<::backbonerpc::Request>*
    AsyncPublishRaw(::grpc::ClientContext* context,
                    ::backbonerpc::Response* response,
                    ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncWriterInterface<::backbonerpc::Request>*
    PrepareAsyncPublishRaw(::grpc::ClientContext* context,
                           ::backbonerpc::Response* response,
                           ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr<::grpc::ChannelInterface>& channel,
         const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status Call(::grpc::ClientContext* context,
                        const ::backbonerpc::Request& request,
                        ::backbonerpc::Response* response) override;
    std::unique_ptr<::grpc::ClientAsyncResponseReader<::backbonerpc::Response>>
    AsyncCall(::grpc::ClientContext* context,
              const ::backbonerpc::Request& request,
              ::grpc::CompletionQueue* cq) {
      return std::unique_ptr<
          ::grpc::ClientAsyncResponseReader<::backbonerpc::Response>>(
          AsyncCallRaw(context, request, cq));
    }
    std::unique_ptr<::grpc::ClientAsyncResponseReader<::backbonerpc::Response>>
    PrepareAsyncCall(::grpc::ClientContext* context,
                     const ::backbonerpc::Request& request,
                     ::grpc::CompletionQueue* cq) {
      return std::unique_ptr<
          ::grpc::ClientAsyncResponseReader<::backbonerpc::Response>>(
          PrepareAsyncCallRaw(context, request, cq));
    }
    std::unique_ptr<::grpc::ClientReader<::backbonerpc::Response>> Pull(
        ::grpc::ClientContext* context, const ::backbonerpc::Request& request) {
      return std::unique_ptr<::grpc::ClientReader<::backbonerpc::Response>>(
          PullRaw(context, request));
    }
    std::unique_ptr<::grpc::ClientAsyncReader<::backbonerpc::Response>>
    AsyncPull(::grpc::ClientContext* context,
              const ::backbonerpc::Request& request,
              ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr<
          ::grpc::ClientAsyncReader<::backbonerpc::Response>>(
          AsyncPullRaw(context, request, cq, tag));
    }
    std::unique_ptr<::grpc::ClientAsyncReader<::backbonerpc::Response>>
    PrepareAsyncPull(::grpc::ClientContext* context,
                     const ::backbonerpc::Request& request,
                     ::grpc::CompletionQueue* cq) {
      return std::unique_ptr<
          ::grpc::ClientAsyncReader<::backbonerpc::Response>>(
          PrepareAsyncPullRaw(context, request, cq));
    }
    std::unique_ptr<::grpc::ClientWriter<::backbonerpc::Request>> Push(
        ::grpc::ClientContext* context, ::backbonerpc::Response* response) {
      return std::unique_ptr<::grpc::ClientWriter<::backbonerpc::Request>>(
          PushRaw(context, response));
    }
    std::unique_ptr<::grpc::ClientAsyncWriter<::backbonerpc::Request>>
    AsyncPush(::grpc::ClientContext* context, ::backbonerpc::Response* response,
              ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr<::grpc::ClientAsyncWriter<::backbonerpc::Request>>(
          AsyncPushRaw(context, response, cq, tag));
    }
    std::unique_ptr<::grpc::ClientAsyncWriter<::backbonerpc::Request>>
    PrepareAsyncPush(::grpc::ClientContext* context,
                     ::backbonerpc::Response* response,
                     ::grpc::CompletionQueue* cq) {
      return std::unique_ptr<::grpc::ClientAsyncWriter<::backbonerpc::Request>>(
          PrepareAsyncPushRaw(context, response, cq));
    }
    std::unique_ptr<::grpc::ClientReaderWriter<::backbonerpc::Request,
                                               ::backbonerpc::Response>>
    Bidi(::grpc::ClientContext* context) {
      return std::unique_ptr<::grpc::ClientReaderWriter<
          ::backbonerpc::Request, ::backbonerpc::Response>>(BidiRaw(context));
    }
    std::unique_ptr<::grpc::ClientAsyncReaderWriter<::backbonerpc::Request,
                                                    ::backbonerpc::Response>>
    AsyncBidi(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq,
              void* tag) {
      return std::unique_ptr<::grpc::ClientAsyncReaderWriter<
          ::backbonerpc::Request, ::backbonerpc::Response>>(
          AsyncBidiRaw(context, cq, tag));
    }
    std::unique_ptr<::grpc::ClientAsyncReaderWriter<::backbonerpc::Request,
                                                    ::backbonerpc::Response>>
    PrepareAsyncBidi(::grpc::ClientContext* context,
                     ::grpc::CompletionQueue* cq) {
      return std::unique_ptr<::grpc::ClientAsyncReaderWriter<
          ::backbonerpc::Request, ::backbonerpc::Response>>(
          PrepareAsyncBidiRaw(context, cq));
    }
    std::unique_ptr<::grpc::ClientReader<::backbonerpc::Response>> Subscribe(
        ::grpc::ClientContext* context, const ::backbonerpc::Request& request) {
      return std::unique_ptr<::grpc::ClientReader<::backbonerpc::Response>>(
          SubscribeRaw(context, request));
    }
    std::unique_ptr<::grpc::ClientAsyncReader<::backbonerpc::Response>>
    AsyncSubscribe(::grpc::ClientContext* context,
                   const ::backbonerpc::Request& request,
                   ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr<
          ::grpc::ClientAsyncReader<::backbonerpc::Response>>(
          AsyncSubscribeRaw(context, request, cq, tag));
    }
    std::unique_ptr<::grpc::ClientAsyncReader<::backbonerpc::Response>>
    PrepareAsyncSubscribe(::grpc::ClientContext* context,
                          const ::backbonerpc::Request& request,
                          ::grpc::CompletionQueue* cq) {
      return std::unique_ptr<
          ::grpc::ClientAsyncReader<::backbonerpc::Response>>(
          PrepareAsyncSubscribeRaw(context, request, cq));
    }
    std::unique_ptr<::grpc::ClientWriter<::backbonerpc::Request>> Publish(
        ::grpc::ClientContext* context, ::backbonerpc::Response* response) {
      return std::unique_ptr<::grpc::ClientWriter<::backbonerpc::Request>>(
          PublishRaw(context, response));
    }
    std::unique_ptr<::grpc::ClientAsyncWriter<::backbonerpc::Request>>
    AsyncPublish(::grpc::ClientContext* context,
                 ::backbonerpc::Response* response, ::grpc::CompletionQueue* cq,
                 void* tag) {
      return std::unique_ptr<::grpc::ClientAsyncWriter<::backbonerpc::Request>>(
          AsyncPublishRaw(context, response, cq, tag));
    }
    std::unique_ptr<::grpc::ClientAsyncWriter<::backbonerpc::Request>>
    PrepareAsyncPublish(::grpc::ClientContext* context,
                        ::backbonerpc::Response* response,
                        ::grpc::CompletionQueue* cq) {
      return std::unique_ptr<::grpc::ClientAsyncWriter<::backbonerpc::Request>>(
          PrepareAsyncPublishRaw(context, response, cq));
    }
    class async final : public StubInterface::async_interface {
     public:
      void Call(::grpc::ClientContext* context,
                const ::backbonerpc::Request* request,
                ::backbonerpc::Response* response,
                std::function<void(::grpc::Status)>) override;
      void Call(::grpc::ClientContext* context,
                const ::backbonerpc::Request* request,
                ::backbonerpc::Response* response,
                ::grpc::ClientUnaryReactor* reactor) override;
      void Pull(
          ::grpc::ClientContext* context, const ::backbonerpc::Request* request,
          ::grpc::ClientReadReactor<::backbonerpc::Response>* reactor) override;
      void Push(
          ::grpc::ClientContext* context, ::backbonerpc::Response* response,
          ::grpc::ClientWriteReactor<::backbonerpc::Request>* reactor) override;
      void Bidi(
          ::grpc::ClientContext* context,
          ::grpc::ClientBidiReactor<::backbonerpc::Request,
                                    ::backbonerpc::Response>* reactor) override;
      void Subscribe(
          ::grpc::ClientContext* context, const ::backbonerpc::Request* request,
          ::grpc::ClientReadReactor<::backbonerpc::Response>* reactor) override;
      void Publish(
          ::grpc::ClientContext* context, ::backbonerpc::Response* response,
          ::grpc::ClientWriteReactor<::backbonerpc::Request>* reactor) override;

     private:
      friend class Stub;
      explicit async(Stub* stub) : stub_(stub) {}
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr<::grpc::ChannelInterface> channel_;
    class async async_stub_ {
      this
    };
    ::grpc::ClientAsyncResponseReader<::backbonerpc::Response>* AsyncCallRaw(
        ::grpc::ClientContext* context, const ::backbonerpc::Request& request,
        ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader<::backbonerpc::Response>*
    PrepareAsyncCallRaw(::grpc::ClientContext* context,
                        const ::backbonerpc::Request& request,
                        ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader<::backbonerpc::Response>* PullRaw(
        ::grpc::ClientContext* context,
        const ::backbonerpc::Request& request) override;
    ::grpc::ClientAsyncReader<::backbonerpc::Response>* AsyncPullRaw(
        ::grpc::ClientContext* context, const ::backbonerpc::Request& request,
        ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader<::backbonerpc::Response>* PrepareAsyncPullRaw(
        ::grpc::ClientContext* context, const ::backbonerpc::Request& request,
        ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientWriter<::backbonerpc::Request>* PushRaw(
        ::grpc::ClientContext* context,
        ::backbonerpc::Response* response) override;
    ::grpc::ClientAsyncWriter<::backbonerpc::Request>* AsyncPushRaw(
        ::grpc::ClientContext* context, ::backbonerpc::Response* response,
        ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncWriter<::backbonerpc::Request>* PrepareAsyncPushRaw(
        ::grpc::ClientContext* context, ::backbonerpc::Response* response,
        ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReaderWriter<::backbonerpc::Request, ::backbonerpc::Response>*
    BidiRaw(::grpc::ClientContext* context) override;
    ::grpc::ClientAsyncReaderWriter<::backbonerpc::Request,
                                    ::backbonerpc::Response>*
    AsyncBidiRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq,
                 void* tag) override;
    ::grpc::ClientAsyncReaderWriter<::backbonerpc::Request,
                                    ::backbonerpc::Response>*
    PrepareAsyncBidiRaw(::grpc::ClientContext* context,
                        ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader<::backbonerpc::Response>* SubscribeRaw(
        ::grpc::ClientContext* context,
        const ::backbonerpc::Request& request) override;
    ::grpc::ClientAsyncReader<::backbonerpc::Response>* AsyncSubscribeRaw(
        ::grpc::ClientContext* context, const ::backbonerpc::Request& request,
        ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader<::backbonerpc::Response>*
    PrepareAsyncSubscribeRaw(::grpc::ClientContext* context,
                             const ::backbonerpc::Request& request,
                             ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientWriter<::backbonerpc::Request>* PublishRaw(
        ::grpc::ClientContext* context,
        ::backbonerpc::Response* response) override;
    ::grpc::ClientAsyncWriter<::backbonerpc::Request>* AsyncPublishRaw(
        ::grpc::ClientContext* context, ::backbonerpc::Response* response,
        ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncWriter<::backbonerpc::Request>* PrepareAsyncPublishRaw(
        ::grpc::ClientContext* context, ::backbonerpc::Response* response,
        ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_Call_;
    const ::grpc::internal::RpcMethod rpcmethod_Pull_;
    const ::grpc::internal::RpcMethod rpcmethod_Push_;
    const ::grpc::internal::RpcMethod rpcmethod_Bidi_;
    const ::grpc::internal::RpcMethod rpcmethod_Subscribe_;
    const ::grpc::internal::RpcMethod rpcmethod_Publish_;
  };
  static std::unique_ptr<Stub> NewStub(
      const std::shared_ptr<::grpc::ChannelInterface>& channel,
      const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status Call(::grpc::ServerContext* context,
                                const ::backbonerpc::Request* request,
                                ::backbonerpc::Response* response);
    virtual ::grpc::Status Pull(
        ::grpc::ServerContext* context, const ::backbonerpc::Request* request,
        ::grpc::ServerWriter<::backbonerpc::Response>* writer);
    virtual ::grpc::Status Push(
        ::grpc::ServerContext* context,
        ::grpc::ServerReader<::backbonerpc::Request>* reader,
        ::backbonerpc::Response* response);
    virtual ::grpc::Status Bidi(
        ::grpc::ServerContext* context,
        ::grpc::ServerReaderWriter<::backbonerpc::Response,
                                   ::backbonerpc::Request>* stream);
    virtual ::grpc::Status Subscribe(
        ::grpc::ServerContext* context, const ::backbonerpc::Request* request,
        ::grpc::ServerWriter<::backbonerpc::Response>* writer);
    virtual ::grpc::Status Publish(
        ::grpc::ServerContext* context,
        ::grpc::ServerReader<::backbonerpc::Request>* reader,
        ::backbonerpc::Response* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_Call : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

   public:
    WithAsyncMethod_Call() { ::grpc::Service::MarkMethodAsync(0); }
    ~WithAsyncMethod_Call() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Call(::grpc::ServerContext* /*context*/,
                        const ::backbonerpc::Request* /*request*/,
                        ::backbonerpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCall(
        ::grpc::ServerContext* context, ::backbonerpc::Request* request,
        ::grpc::ServerAsyncResponseWriter<::backbonerpc::Response>* response,
        ::grpc::CompletionQueue* new_call_cq,
        ::grpc::ServerCompletionQueue* notification_cq, void* tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response,
                                         new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Pull : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

   public:
    WithAsyncMethod_Pull() { ::grpc::Service::MarkMethodAsync(1); }
    ~WithAsyncMethod_Pull() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Pull(
        ::grpc::ServerContext* /*context*/,
        const ::backbonerpc::Request* /*request*/,
        ::grpc::ServerWriter<::backbonerpc::Response>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPull(::grpc::ServerContext* context,
                     ::backbonerpc::Request* request,
                     ::grpc::ServerAsyncWriter<::backbonerpc::Response>* writer,
                     ::grpc::CompletionQueue* new_call_cq,
                     ::grpc::ServerCompletionQueue* notification_cq,
                     void* tag) {
      ::grpc::Service::RequestAsyncServerStreaming(
          1, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Push : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

   public:
    WithAsyncMethod_Push() { ::grpc::Service::MarkMethodAsync(2); }
    ~WithAsyncMethod_Push() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Push(
        ::grpc::ServerContext* /*context*/,
        ::grpc::ServerReader<::backbonerpc::Request>* /*reader*/,
        ::backbonerpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPush(::grpc::ServerContext* context,
                     ::grpc::ServerAsyncReader<::backbonerpc::Response,
                                               ::backbonerpc::Request>* reader,
                     ::grpc::CompletionQueue* new_call_cq,
                     ::grpc::ServerCompletionQueue* notification_cq,
                     void* tag) {
      ::grpc::Service::RequestAsyncClientStreaming(
          2, context, reader, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Bidi : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

   public:
    WithAsyncMethod_Bidi() { ::grpc::Service::MarkMethodAsync(3); }
    ~WithAsyncMethod_Bidi() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Bidi(
        ::grpc::ServerContext* /*context*/,
        ::grpc::ServerReaderWriter<::backbonerpc::Response,
                                   ::backbonerpc::Request>* /*stream*/)
        override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBidi(
        ::grpc::ServerContext* context,
        ::grpc::ServerAsyncReaderWriter<::backbonerpc::Response,
                                        ::backbonerpc::Request>* stream,
        ::grpc::CompletionQueue* new_call_cq,
        ::grpc::ServerCompletionQueue* notification_cq, void* tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(
          3, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Subscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

   public:
    WithAsyncMethod_Subscribe() { ::grpc::Service::MarkMethodAsync(4); }
    ~WithAsyncMethod_Subscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Subscribe(
        ::grpc::ServerContext* /*context*/,
        const ::backbonerpc::Request* /*request*/,
        ::grpc::ServerWriter<::backbonerpc::Response>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubscribe(
        ::grpc::ServerContext* context, ::backbonerpc::Request* request,
        ::grpc::ServerAsyncWriter<::backbonerpc::Response>* writer,
        ::grpc::CompletionQueue* new_call_cq,
        ::grpc::ServerCompletionQueue* notification_cq, void* tag) {
      ::grpc::Service::RequestAsyncServerStreaming(
          4, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Publish : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

   public:
    WithAsyncMethod_Publish() { ::grpc::Service::MarkMethodAsync(5); }
    ~WithAsyncMethod_Publish() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Publish(
        ::grpc::ServerContext* /*context*/,
        ::grpc::ServerReader<::backbonerpc::Request>* /*reader*/,
        ::backbonerpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPublish(
        ::grpc::ServerContext* context,
        ::grpc::ServerAsyncReader<::backbonerpc::Response,
                                  ::backbonerpc::Request>* reader,
        ::grpc::CompletionQueue* new_call_cq,
        ::grpc::ServerCompletionQueue* notification_cq, void* tag) {
      ::grpc::Service::RequestAsyncClientStreaming(
          5, context, reader, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_Call<
      WithAsyncMethod_Pull<WithAsyncMethod_Push<WithAsyncMethod_Bidi<
          WithAsyncMethod_Subscribe<WithAsyncMethod_Publish<Service>>>>>>
      AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_Call : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

   public:
    WithCallbackMethod_Call() {
      ::grpc::Service::MarkMethodCallback(
          0,
          new ::grpc::internal::CallbackUnaryHandler<::backbonerpc::Request,
                                                     ::backbonerpc::Response>(
              [this](::grpc::CallbackServerContext* context,
                     const ::backbonerpc::Request* request,
                     ::backbonerpc::Response* response) {
                return this->Call(context, request, response);
              }));
    }
    void SetMessageAllocatorFor_Call(
        ::grpc::MessageAllocator<::backbonerpc::Request,
                                 ::backbonerpc::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler =
          ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler<
          ::backbonerpc::Request, ::backbonerpc::Response>*>(handler)
          ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Call() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Call(::grpc::ServerContext* /*context*/,
                        const ::backbonerpc::Request* /*request*/,
                        ::backbonerpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Call(
        ::grpc::CallbackServerContext* /*context*/,
        const ::backbonerpc::Request* /*request*/,
        ::backbonerpc::Response* /*response*/) {
      return nullptr;
    }
  };
  template <class BaseClass>
  class WithCallbackMethod_Pull : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

   public:
    WithCallbackMethod_Pull() {
      ::grpc::Service::MarkMethodCallback(
          1, new ::grpc::internal::CallbackServerStreamingHandler<
                 ::backbonerpc::Request, ::backbonerpc::Response>(
                 [this](::grpc::CallbackServerContext* context,
                        const ::backbonerpc::Request* request) {
                   return this->Pull(context, request);
                 }));
    }
    ~WithCallbackMethod_Pull() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Pull(
        ::grpc::ServerContext* /*context*/,
        const ::backbonerpc::Request* /*request*/,
        ::grpc::ServerWriter<::backbonerpc::Response>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor<::backbonerpc::Response>* Pull(
        ::grpc::CallbackServerContext* /*context*/,
        const ::backbonerpc::Request* /*request*/) {
      return nullptr;
    }
  };
  template <class BaseClass>
  class WithCallbackMethod_Push : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

   public:
    WithCallbackMethod_Push() {
      ::grpc::Service::MarkMethodCallback(
          2, new ::grpc::internal::CallbackClientStreamingHandler<
                 ::backbonerpc::Request, ::backbonerpc::Response>(
                 [this](::grpc::CallbackServerContext* context,
                        ::backbonerpc::Response* response) {
                   return this->Push(context, response);
                 }));
    }
    ~WithCallbackMethod_Push() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Push(
        ::grpc::ServerContext* /*context*/,
        ::grpc::ServerReader<::backbonerpc::Request>* /*reader*/,
        ::backbonerpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerReadReactor<::backbonerpc::Request>* Push(
        ::grpc::CallbackServerContext* /*context*/,
        ::backbonerpc::Response* /*response*/) {
      return nullptr;
    }
  };
  template <class BaseClass>
  class WithCallbackMethod_Bidi : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

   public:
    WithCallbackMethod_Bidi() {
      ::grpc::Service::MarkMethodCallback(
          3, new ::grpc::internal::CallbackBidiHandler<::backbonerpc::Request,
                                                       ::backbonerpc::Response>(
                 [this](::grpc::CallbackServerContext* context) {
                   return this->Bidi(context);
                 }));
    }
    ~WithCallbackMethod_Bidi() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Bidi(
        ::grpc::ServerContext* /*context*/,
        ::grpc::ServerReaderWriter<::backbonerpc::Response,
                                   ::backbonerpc::Request>* /*stream*/)
        override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerBidiReactor<::backbonerpc::Request,
                                      ::backbonerpc::Response>*
    Bidi(::grpc::CallbackServerContext* /*context*/) {
      return nullptr;
    }
  };
  template <class BaseClass>
  class WithCallbackMethod_Subscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

   public:
    WithCallbackMethod_Subscribe() {
      ::grpc::Service::MarkMethodCallback(
          4, new ::grpc::internal::CallbackServerStreamingHandler<
                 ::backbonerpc::Request, ::backbonerpc::Response>(
                 [this](::grpc::CallbackServerContext* context,
                        const ::backbonerpc::Request* request) {
                   return this->Subscribe(context, request);
                 }));
    }
    ~WithCallbackMethod_Subscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Subscribe(
        ::grpc::ServerContext* /*context*/,
        const ::backbonerpc::Request* /*request*/,
        ::grpc::ServerWriter<::backbonerpc::Response>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor<::backbonerpc::Response>* Subscribe(
        ::grpc::CallbackServerContext* /*context*/,
        const ::backbonerpc::Request* /*request*/) {
      return nullptr;
    }
  };
  template <class BaseClass>
  class WithCallbackMethod_Publish : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

   public:
    WithCallbackMethod_Publish() {
      ::grpc::Service::MarkMethodCallback(
          5, new ::grpc::internal::CallbackClientStreamingHandler<
                 ::backbonerpc::Request, ::backbonerpc::Response>(
                 [this](::grpc::CallbackServerContext* context,
                        ::backbonerpc::Response* response) {
                   return this->Publish(context, response);
                 }));
    }
    ~WithCallbackMethod_Publish() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Publish(
        ::grpc::ServerContext* /*context*/,
        ::grpc::ServerReader<::backbonerpc::Request>* /*reader*/,
        ::backbonerpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerReadReactor<::backbonerpc::Request>* Publish(
        ::grpc::CallbackServerContext* /*context*/,
        ::backbonerpc::Response* /*response*/) {
      return nullptr;
    }
  };
  typedef WithCallbackMethod_Call<
      WithCallbackMethod_Pull<WithCallbackMethod_Push<WithCallbackMethod_Bidi<
          WithCallbackMethod_Subscribe<WithCallbackMethod_Publish<Service>>>>>>
      CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_Call : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

   public:
    WithGenericMethod_Call() { ::grpc::Service::MarkMethodGeneric(0); }
    ~WithGenericMethod_Call() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Call(::grpc::ServerContext* /*context*/,
                        const ::backbonerpc::Request* /*request*/,
                        ::backbonerpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Pull : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

   public:
    WithGenericMethod_Pull() { ::grpc::Service::MarkMethodGeneric(1); }
    ~WithGenericMethod_Pull() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Pull(
        ::grpc::ServerContext* /*context*/,
        const ::backbonerpc::Request* /*request*/,
        ::grpc::ServerWriter<::backbonerpc::Response>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Push : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

   public:
    WithGenericMethod_Push() { ::grpc::Service::MarkMethodGeneric(2); }
    ~WithGenericMethod_Push() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Push(
        ::grpc::ServerContext* /*context*/,
        ::grpc::ServerReader<::backbonerpc::Request>* /*reader*/,
        ::backbonerpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Bidi : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

   public:
    WithGenericMethod_Bidi() { ::grpc::Service::MarkMethodGeneric(3); }
    ~WithGenericMethod_Bidi() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Bidi(
        ::grpc::ServerContext* /*context*/,
        ::grpc::ServerReaderWriter<::backbonerpc::Response,
                                   ::backbonerpc::Request>* /*stream*/)
        override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Subscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

   public:
    WithGenericMethod_Subscribe() { ::grpc::Service::MarkMethodGeneric(4); }
    ~WithGenericMethod_Subscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Subscribe(
        ::grpc::ServerContext* /*context*/,
        const ::backbonerpc::Request* /*request*/,
        ::grpc::ServerWriter<::backbonerpc::Response>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Publish : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

   public:
    WithGenericMethod_Publish() { ::grpc::Service::MarkMethodGeneric(5); }
    ~WithGenericMethod_Publish() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Publish(
        ::grpc::ServerContext* /*context*/,
        ::grpc::ServerReader<::backbonerpc::Request>* /*reader*/,
        ::backbonerpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_Call : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

   public:
    WithRawMethod_Call() { ::grpc::Service::MarkMethodRaw(0); }
    ~WithRawMethod_Call() override { BaseClassMustBeDerivedFromService(this); }
    // disable synchronous version of this method
    ::grpc::Status Call(::grpc::ServerContext* /*context*/,
                        const ::backbonerpc::Request* /*request*/,
                        ::backbonerpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCall(
        ::grpc::ServerContext* context, ::grpc::ByteBuffer* request,
        ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer>* response,
        ::grpc::CompletionQueue* new_call_cq,
        ::grpc::ServerCompletionQueue* notification_cq, void* tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response,
                                         new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Pull : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

   public:
    WithRawMethod_Pull() { ::grpc::Service::MarkMethodRaw(1); }
    ~WithRawMethod_Pull() override { BaseClassMustBeDerivedFromService(this); }
    // disable synchronous version of this method
    ::grpc::Status Pull(
        ::grpc::ServerContext* /*context*/,
        const ::backbonerpc::Request* /*request*/,
        ::grpc::ServerWriter<::backbonerpc::Response>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPull(::grpc::ServerContext* context,
                     ::grpc::ByteBuffer* request,
                     ::grpc::ServerAsyncWriter<::grpc::ByteBuffer>* writer,
                     ::grpc::CompletionQueue* new_call_cq,
                     ::grpc::ServerCompletionQueue* notification_cq,
                     void* tag) {
      ::grpc::Service::RequestAsyncServerStreaming(
          1, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Push : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

   public:
    WithRawMethod_Push() { ::grpc::Service::MarkMethodRaw(2); }
    ~WithRawMethod_Push() override { BaseClassMustBeDerivedFromService(this); }
    // disable synchronous version of this method
    ::grpc::Status Push(
        ::grpc::ServerContext* /*context*/,
        ::grpc::ServerReader<::backbonerpc::Request>* /*reader*/,
        ::backbonerpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPush(::grpc::ServerContext* context,
                     ::grpc::ServerAsyncReader<::grpc::ByteBuffer,
                                               ::grpc::ByteBuffer>* reader,
                     ::grpc::CompletionQueue* new_call_cq,
                     ::grpc::ServerCompletionQueue* notification_cq,
                     void* tag) {
      ::grpc::Service::RequestAsyncClientStreaming(
          2, context, reader, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Bidi : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

   public:
    WithRawMethod_Bidi() { ::grpc::Service::MarkMethodRaw(3); }
    ~WithRawMethod_Bidi() override { BaseClassMustBeDerivedFromService(this); }
    // disable synchronous version of this method
    ::grpc::Status Bidi(
        ::grpc::ServerContext* /*context*/,
        ::grpc::ServerReaderWriter<::backbonerpc::Response,
                                   ::backbonerpc::Request>* /*stream*/)
        override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBidi(
        ::grpc::ServerContext* context,
        ::grpc::ServerAsyncReaderWriter<::grpc::ByteBuffer, ::grpc::ByteBuffer>*
            stream,
        ::grpc::CompletionQueue* new_call_cq,
        ::grpc::ServerCompletionQueue* notification_cq, void* tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(
          3, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Subscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

   public:
    WithRawMethod_Subscribe() { ::grpc::Service::MarkMethodRaw(4); }
    ~WithRawMethod_Subscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Subscribe(
        ::grpc::ServerContext* /*context*/,
        const ::backbonerpc::Request* /*request*/,
        ::grpc::ServerWriter<::backbonerpc::Response>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubscribe(::grpc::ServerContext* context,
                          ::grpc::ByteBuffer* request,
                          ::grpc::ServerAsyncWriter<::grpc::ByteBuffer>* writer,
                          ::grpc::CompletionQueue* new_call_cq,
                          ::grpc::ServerCompletionQueue* notification_cq,
                          void* tag) {
      ::grpc::Service::RequestAsyncServerStreaming(
          4, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Publish : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

   public:
    WithRawMethod_Publish() { ::grpc::Service::MarkMethodRaw(5); }
    ~WithRawMethod_Publish() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Publish(
        ::grpc::ServerContext* /*context*/,
        ::grpc::ServerReader<::backbonerpc::Request>* /*reader*/,
        ::backbonerpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPublish(::grpc::ServerContext* context,
                        ::grpc::ServerAsyncReader<::grpc::ByteBuffer,
                                                  ::grpc::ByteBuffer>* reader,
                        ::grpc::CompletionQueue* new_call_cq,
                        ::grpc::ServerCompletionQueue* notification_cq,
                        void* tag) {
      ::grpc::Service::RequestAsyncClientStreaming(
          5, context, reader, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Call : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

   public:
    WithRawCallbackMethod_Call() {
      ::grpc::Service::MarkMethodRawCallback(
          0, new ::grpc::internal::CallbackUnaryHandler<::grpc::ByteBuffer,
                                                        ::grpc::ByteBuffer>(
                 [this](::grpc::CallbackServerContext* context,
                        const ::grpc::ByteBuffer* request,
                        ::grpc::ByteBuffer* response) {
                   return this->Call(context, request, response);
                 }));
    }
    ~WithRawCallbackMethod_Call() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Call(::grpc::ServerContext* /*context*/,
                        const ::backbonerpc::Request* /*request*/,
                        ::backbonerpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Call(
        ::grpc::CallbackServerContext* /*context*/,
        const ::grpc::ByteBuffer* /*request*/,
        ::grpc::ByteBuffer* /*response*/) {
      return nullptr;
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Pull : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

   public:
    WithRawCallbackMethod_Pull() {
      ::grpc::Service::MarkMethodRawCallback(
          1, new ::grpc::internal::CallbackServerStreamingHandler<
                 ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
                 [this](::grpc::CallbackServerContext* context,
                        const ::grpc::ByteBuffer* request) {
                   return this->Pull(context, request);
                 }));
    }
    ~WithRawCallbackMethod_Pull() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Pull(
        ::grpc::ServerContext* /*context*/,
        const ::backbonerpc::Request* /*request*/,
        ::grpc::ServerWriter<::backbonerpc::Response>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor<::grpc::ByteBuffer>* Pull(
        ::grpc::CallbackServerContext* /*context*/,
        const ::grpc::ByteBuffer* /*request*/) {
      return nullptr;
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Push : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

   public:
    WithRawCallbackMethod_Push() {
      ::grpc::Service::MarkMethodRawCallback(
          2, new ::grpc::internal::CallbackClientStreamingHandler<
                 ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
                 [this](::grpc::CallbackServerContext* context,
                        ::grpc::ByteBuffer* response) {
                   return this->Push(context, response);
                 }));
    }
    ~WithRawCallbackMethod_Push() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Push(
        ::grpc::ServerContext* /*context*/,
        ::grpc::ServerReader<::backbonerpc::Request>* /*reader*/,
        ::backbonerpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerReadReactor<::grpc::ByteBuffer>* Push(
        ::grpc::CallbackServerContext* /*context*/,
        ::grpc::ByteBuffer* /*response*/) {
      return nullptr;
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Bidi : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

   public:
    WithRawCallbackMethod_Bidi() {
      ::grpc::Service::MarkMethodRawCallback(
          3, new ::grpc::internal::CallbackBidiHandler<::grpc::ByteBuffer,
                                                       ::grpc::ByteBuffer>(
                 [this](::grpc::CallbackServerContext* context) {
                   return this->Bidi(context);
                 }));
    }
    ~WithRawCallbackMethod_Bidi() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Bidi(
        ::grpc::ServerContext* /*context*/,
        ::grpc::ServerReaderWriter<::backbonerpc::Response,
                                   ::backbonerpc::Request>* /*stream*/)
        override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerBidiReactor<::grpc::ByteBuffer, ::grpc::ByteBuffer>*
    Bidi(::grpc::CallbackServerContext* /*context*/) {
      return nullptr;
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Subscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

   public:
    WithRawCallbackMethod_Subscribe() {
      ::grpc::Service::MarkMethodRawCallback(
          4, new ::grpc::internal::CallbackServerStreamingHandler<
                 ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
                 [this](::grpc::CallbackServerContext* context,
                        const ::grpc::ByteBuffer* request) {
                   return this->Subscribe(context, request);
                 }));
    }
    ~WithRawCallbackMethod_Subscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Subscribe(
        ::grpc::ServerContext* /*context*/,
        const ::backbonerpc::Request* /*request*/,
        ::grpc::ServerWriter<::backbonerpc::Response>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor<::grpc::ByteBuffer>* Subscribe(
        ::grpc::CallbackServerContext* /*context*/,
        const ::grpc::ByteBuffer* /*request*/) {
      return nullptr;
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Publish : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

   public:
    WithRawCallbackMethod_Publish() {
      ::grpc::Service::MarkMethodRawCallback(
          5, new ::grpc::internal::CallbackClientStreamingHandler<
                 ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
                 [this](::grpc::CallbackServerContext* context,
                        ::grpc::ByteBuffer* response) {
                   return this->Publish(context, response);
                 }));
    }
    ~WithRawCallbackMethod_Publish() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Publish(
        ::grpc::ServerContext* /*context*/,
        ::grpc::ServerReader<::backbonerpc::Request>* /*reader*/,
        ::backbonerpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerReadReactor<::grpc::ByteBuffer>* Publish(
        ::grpc::CallbackServerContext* /*context*/,
        ::grpc::ByteBuffer* /*response*/) {
      return nullptr;
    }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Call : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

   public:
    WithStreamedUnaryMethod_Call() {
      ::grpc::Service::MarkMethodStreamed(
          0,
          new ::grpc::internal::StreamedUnaryHandler<::backbonerpc::Request,
                                                     ::backbonerpc::Response>(
              [this](::grpc::ServerContext* context,
                     ::grpc::ServerUnaryStreamer<::backbonerpc::Request,
                                                 ::backbonerpc::Response>*
                         streamer) {
                return this->StreamedCall(context, streamer);
              }));
    }
    ~WithStreamedUnaryMethod_Call() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Call(::grpc::ServerContext* /*context*/,
                        const ::backbonerpc::Request* /*request*/,
                        ::backbonerpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCall(
        ::grpc::ServerContext* context,
        ::grpc::ServerUnaryStreamer<::backbonerpc::Request,
                                    ::backbonerpc::Response>*
            server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_Call<Service> StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_Pull : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

   public:
    WithSplitStreamingMethod_Pull() {
      ::grpc::Service::MarkMethodStreamed(
          1, new ::grpc::internal::SplitServerStreamingHandler<
                 ::backbonerpc::Request, ::backbonerpc::Response>(
                 [this](::grpc::ServerContext* context,
                        ::grpc::ServerSplitStreamer<::backbonerpc::Request,
                                                    ::backbonerpc::Response>*
                            streamer) {
                   return this->StreamedPull(context, streamer);
                 }));
    }
    ~WithSplitStreamingMethod_Pull() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Pull(
        ::grpc::ServerContext* /*context*/,
        const ::backbonerpc::Request* /*request*/,
        ::grpc::ServerWriter<::backbonerpc::Response>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedPull(
        ::grpc::ServerContext* context,
        ::grpc::ServerSplitStreamer<::backbonerpc::Request,
                                    ::backbonerpc::Response>*
            server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_Subscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

   public:
    WithSplitStreamingMethod_Subscribe() {
      ::grpc::Service::MarkMethodStreamed(
          4, new ::grpc::internal::SplitServerStreamingHandler<
                 ::backbonerpc::Request, ::backbonerpc::Response>(
                 [this](::grpc::ServerContext* context,
                        ::grpc::ServerSplitStreamer<::backbonerpc::Request,
                                                    ::backbonerpc::Response>*
                            streamer) {
                   return this->StreamedSubscribe(context, streamer);
                 }));
    }
    ~WithSplitStreamingMethod_Subscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Subscribe(
        ::grpc::ServerContext* /*context*/,
        const ::backbonerpc::Request* /*request*/,
        ::grpc::ServerWriter<::backbonerpc::Response>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedSubscribe(
        ::grpc::ServerContext* context,
        ::grpc::ServerSplitStreamer<::backbonerpc::Request,
                                    ::backbonerpc::Response>*
            server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_Pull<
      WithSplitStreamingMethod_Subscribe<Service>>
      SplitStreamedService;
  typedef WithStreamedUnaryMethod_Call<WithSplitStreamingMethod_Pull<
      WithSplitStreamingMethod_Subscribe<Service>>>
      StreamedService;
};

}  // namespace backbonerpc

#endif  // GRPC_xgrpc_2eproto__INCLUDED
